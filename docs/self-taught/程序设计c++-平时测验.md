## 程序设计C++04737

### 平时测验一

1. 假定A为一个类，a()为该类公有的函数成员，x为该类的一个对象，则访问x对象中函数成员a()的格式为（）:  **x.a()**
   
    > 答案解析：对象访问成员的方式为：对象名.成员。指针可以有两种：(*对象指针).成员或者对象指针->成员。 
2. 析构函数的返回值类型为:  **无类型**
3. 在类中使用static关键字修饰的成员函数称为:  **静态成员函数**
4. 设类A中有静态数据成员x，两个A类对象a和b，若a.x=10，则b.x的值为:  **10**
5. 使用new Point(5，7)创建对象，调用的是下列哪个构造函数？:  **Point::Point(int,int)**
6. 在定义结构时，为产生封装性，则需使用哪个关键字数据成员？:  **private**
7. C++中注释“∥”的有效范围是（      ）:  **从“∥”开始到行尾**
   
    > 答案解析：C++有两种注释方式：①从“/*”开始，到“*/”结束，如：/* …… */；②从“//”开始到本行结束，如：    //……。 
8. 函数重载必须满足的条件是:  **函数名相同**
9. 一个函数功能不太复杂，但要求被频繁调用，则应把它定义为 （ ）:  **内联函数**
   
    > 答案解析：内联函数特征代码少，频繁调用，执行效率高。重载函数解决统一接口的问题；递归是子程序调用，程序调用要耗费很多空间和时间，循环/迭代都比递归有效率得多，递归只是从形式上，逻辑比较简洁。嵌套函数即反复调用，速度较慢。所以选择A项。 
10. 要禁止修改指针p本身，又要禁止修改p所指向的数据，这样的指针应定义为（）:  **const char * const p=“ABCD”；**
    
    > 答案解析：const char *p说明禁止通过p修改所指向的数据。char * const p则说明不能修改指针p的地址。因此const char * const p=“ABCD”；它禁止修改指针p本身，又禁止修改p所指向的数据。 
11. 在编译指令中，宏定义使用的指令是:  **#define**
12. 下列哪种类型的函数适合声明为内联函数？:  **函数语句较少，执行速度要求高**
13. 函数调用func((exp1,exp2),(exp3,exp4,exp5))中所含实参的个数为（）:  **2**
    
    > 答案解析：(exp1,exp2)、(exp3,exp4,exp5)表示是两个逗号表达式，值是最后一个值，相当于两个参数。 
14. 声明函数为内联使用的关键字为:  **inline**
15. C++源程序文件扩展名为(     ):  **.cpp**
    
    > 答案解析：C++源程序文件扩展名为.cpp，目标文件的扩展名是.obj，可执行文件的扩展名是.exe，C语言源程序文件扩展名为.c。 
16. 下列有关重载函数的说法中正确的是（）:  **重载函数必须有不同的形参列表**
    
    > 答案解析：函数的重载必须函数名相同而形参类型或个数不同，与返回值无关。 
17. 不同对象调用同名函数，但导致完全不同行为的现象称为:  **多态性**
18. 类声明的内容用花括号括起来，在花括号后跟哪个符号表示类声明结束？:  **；**
19. 设存在整型变量int x，则下列句与其它三项含义不同的是(     ):  **int* p=&x；**
    
    > 答案解析：选项A中的p是指向对象x的指针，其它三个选项中的p是x的引用。 
20. 类中的protected成员在何处访问？:  **类和子类的成员函数中**
21. C++允许在结构中定义函数，这些函数称为:  **成员函数**
22. 在C++语言中，数据封装要解决的问题是（）:  **防止不同模块之间数据的非法访问**
    
    > 答案解析：封装是指把对象属性和操作结合在一起，构成独立的单元，它的内部信息对外界是隐蔽的，不允许外界直接存取对象的属性，只能通过有限的接口与对象发生联系。类是数据封装的工具，对象是封装的实现。类的访问控制机制体现在类的成员中可以有公有成员、私有成员和保护成员。对于外界而言，只需要知道对象所表现的外部行为，而不必了解内部实现细节。封装体现了面向对象方法的“信息隐蔽和局部化原则”。
23. 使用地址作为实参传给形参，下列说法正确的是（  ）:  **实参与形参是同一对象**
    
    > 答案解析：地址作为实参，表示实参与形参代表同一个对象。如果实参是数值，形参也是普通变量，此时形参是实参的备份。所以选择D项。 
24. C++中函数中的return指令可以:  **0或多条**
25. 若Sample类中的一个成员函数说明如下：
		        void set(Sample& a)，则Sample& a的含义是（）:  **a是类Sample的对象引用，用来作函数Set（）的形参**
    
    > 答案解析：成员函数使用对象的引用作为形参。该函数的功能是将已知对象的所有数据成员的值拷贝给相应对象的所有数据成员，不会建立临时对象，这里是对象的引用所以选择B。 
26. 在类中说明的成员可以使用关键字的是（）:  **public**
    
    > 答案解析：extern用于声明外部变量的。register声明寄存器类型变量。无cpu类型。它们都不能声明类成员。public声明为公有访问权限，所以选择A项。
27. 在C++中，函数原型不能标识（）:  **函数的功能**
    
    > 答案解析：函数的声明，说明函数的参数、返回类型以及函数名，不包括函数体。而函数体决定函数的功能。所以函数的原型不能决定函数的功能。 
28. 基类中的public成员，通过public派生，基在派生类中的可见性为:  **public**
29. 头文件扩展名为:  **h**
30. 关于new运算符的下列描述中，错误的是（）:  **使用它创建对象数组时必须指定初始值**
    
    > 答案解析：运算符new用于建立生存期可控的动态对象，new返回这个对象的指针；New和构造函数一同起作用，当使用new建立一个动态对象时，new首先分配足以保存该类的一个对象所需要的内存，然后自动调用构造函数来初始化这块内存，再返回这个动态对象的地址。使用运算符new建立的动态对象只能用运算符delete删除，所以使用完毕后，一定要记得使用delete释放空间。 
31. 对C++语言和C语言的兼容性，描述正确的是（     ）:  **C++兼容C**
    
    > 答案解析：C++兼容C语言，用C语言写的程序基本上可以不加修改地用于C++｡
32. 基类中的protected成员，通过哪种派生，其在派生类中的可见性为protected?:  **public和protected**
33. 在函数定义中的形参属于（）:  **局部变量**
    
    > 答案解析：形参或函数中定义的变量都是局部变量。在函数外定义的变量是全局变量。 
34. C++对C语言做了很多改进，即从面向过程变成为面向对象的主要原因是（）:  **引进了类和对象的概念**
    
    > 答案解析：C++是一面向对象的语言，面向对象的特征，抽象、多态、继承和封装。 
35. 决定C++语言中函数的返回值类型的是（ ）:  **在定义该函数时所指定的数据类型**
    
    > 答案解析：函数的返回值类型由定义函数时的指定的数据类型决定的。return语句中的表达式类的值要转换成函数的定义时的返回类型。
36. 下列表达式，哪个是声明p为指向常量的常量指针？:  **const int*const p**
37. 使用string建立对象的不正确方法是（  ）:  **string str=‘GOOD’；**
    
    > 答案解析：选项A和C都是正确定义了string的对象并进行了正确的初始化；选项D正确定义了string的对象，没有初始化；选项B正确定义了string的对象，但‘GOOD’表示字符串的方法是错误的。 
38. 函数模板template void Func(T，T)不能具有哪种实例化形式？:  **void Finc( double,int)**	     
39. 用于标识十六进制常量的前缀或后缀是:  **前缀0x**
40. 所谓数据封装就是将一组数据和与这组数据有关操作组装在一起，形成一个实体，这实体也就是（）:  **类**
    
    > 答案解析：类即数据和操作的组合体，数据是类的静态特征，操作是类具有的动作。 



### 平时测验二

1. 已知：p是一个指向类A数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确的是（）:  **A1.*p=5;**
   
    > 答案解析：A中p是指针即地址，错误；B选项中A1不是指针不能使用指向运算符->,错误；“*”比“.”级别要高，所以D选项*A1.p=5相当于(*A1).p=5;错误。 
2. 友元函数的主要作用是（ ）。:  **提高程序的效率**
   
    > 答案解析：类友元函数应被看作类的接口的一部分，使用它的主要目的是提高效率，因为它可以直接访问对象的私有成员，从而省去调用类的相应成员函数的开销。
3. 在C++中，字符型数据在内存中的存放形式为（ ）。:  **ASCII**
   
    > 答案解析：在C++和C语言中，字符型数据在内存中的存放形式为ASCII码。
4. 下列运算符中，在C++语言中不能重载的是（）:  **::**
   
    > 答案解析：C++的运算符大部分都可以重载，除了. :: *和? :五种运算符，前三者是因为有特殊含义，后两者是因为不值得；另外，sizeof和#不是运算符，故不能重载；而＝ （） [ ] ->这四个运算符只能用类运算符来重载。 
5. 不能作为函数重载的判断依据的是（ ）。:  **返回类型**
   
    > 答案解析：函数重载就是为同一个函数定义几个版本，从而使一个函数名具有多种功能，也称函数多态性。这些函数的多种版本之间的区别有两个，一是参数类型不同，二是参数个数不同；重载函数常用来实现功能类似而所处理的数据类型不同的问题。但是重载函数的返回值类型可以不同。
6. 以下关于运算符重载的描述中，错误的是（ ）。:  **成员运算符比友元运算符多一个参数**
   
    > 答案解析：C++的任何运算都是通过函数来实现的，运算符重载其实就是函数重载，这就是运算符重载的实质。C++中关键字operator和运算符连用就表示一个运算符函数。类运算符比友元运算符少一个参数，这是因为类运算符函数作为成员函数时具有this指针。
7. 运算符[  ]只能用（      ）运算符来重载，不能用友元运算符来重载。:  **类**
   
    > 答案解析：运算符[  ]只能用类运算符来重载，不能用友元运算符来重载。 
8. 已知f1和f2是同一类的两个成员函数，但f1不能直接调用f2，这说明（）:  **f1是静态函数，f2不是静态函数**
   
    > 答案解析：普通成员函数可以调用静态函数，相反静态函数不能调用普通成员函数，这与普通函数与常成员函数相同。因此选择C项。 
9. 已知：“int a=5；char c='a’；”则输出语句cout<<c+1<<a<<c；的显示结果是（ ）。:  **985a**
   
    > 答案解析：c='a’，c+1=97+1=98；a的值是5，c的值是'a’，所以输出语句cout<<c+1<<a<<c；的显示结果是985a。
10. 下列关于静态数据成员的描述中正确的是（）:  **静态数据成员不能通过类的对象调用**
    
    > 答案解析：静态成员属于类的即所有对象所共享的，只能在外部进行初始化，静态数据成员不能通过类的对象调用。所以选择D项。 
11. 如果类A被说明成类B的友元，则（）:  **类B不一定是类A的友元**
    
    > 答案解析：友元关系不能被继承，友元关系是单向的，友元关系不具有传递性。但是友元函数不是类的成员，所以选择A项。
12. 有以下程序段，![image-20210728111855215](https://gitee.com/lcxm/images/raw/master/typora/20210728111904.png)其输出结果是（ ）。:  **Hello! you**
    
    > 答案解析：数组b开始存放的是字符串“Hell，you”，执行b[5]='!'后，数组b存放的是字符串变成“Hello！you”，所以输出Hello! you。
13. C++语言的跳转语句中，对于break和continue说法正确的是（ ）。:  **continue语句只应用于循环体中**
    
    > 答案解析：break语句用于switch语句和循环体中，用于退出switch语句或退出循环；continue语句只应用于循环体中，用于提前结束本次循环。
14. 下列函数的说明中，表示纯虚函数的是（ ）。:  **virtual void vf()=0**
    
    > 答案解析：许多情况下，不能在基类中为虚函数给出一个有意义的定义，此时可将它说明为纯虚函数，将其定义留给派生类去做，说明纯虚函数的一般形式为：virtual 函数类型 函数名（参数列表）＝0；
15. 友元关系不能（）:  **继承**
    
    > 答案解析：友元可以是函数与类的关系即友元函数，也可以是类与类的关系即友元类，但友元不能继承，是单向性，且不具有传递性。友元可以访问类中所有成员，提高了访问的方便性。因此选择D项。 
16. 下列关于运算符重载的表述中，正确的是:  **在类型转换符函数的定义中不需要声明返回类型**
    
    > 答案解析：运算符重载时要遵循以下规则：(1)除了类属关系运算符“.”、成员指针运算符“.*”、作用域运算符“::”、sizeof运算符和三目运算符“?:”以外，C++中的所有运算符都可以重载。(2)重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。(3)重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。  
17. 下列运算符不能重载的是（ ）:  **sizeof**
    
    > 答案解析：C++的运算符大部分都可以重载，除了.、 :: 、*和? :四种运算符，前三者是因为有特殊含义，条件运算符? :是因为不值得；另外sizeof和#不能重载。 
18. 对于下面定义的类Myclass，![image-20210728114532065](https://gitee.com/lcxm/images/raw/master/typora/20210728114534.png)在函数f()中将对象成员n的值修改为50的语句应该是（ ）。:  **p->>SetNum（50）**
    
    > 答案解析：指针p所指对象的数据成员使用运算符“->”，使用指针p调用函数SetNum（50）重设n的值为50。
19. 假定一个类的构造函数为“A(int i=4, int j=0) {a=i;b=j;}”, 则执行“A x (1);”语句后，x.a和x.b的值分别为（）:  **1和0**
    
    > 答案解析：带默认的构造函数，对应实参没有值时就采用形参值。调用构造函数时，i=1,不采用默认值，而只有一个参数，j采用默认值0,因此a=1,b=0,选择A项。 
20. 下列不是描述类的成员函数的是（）:  **友元函数**
    
    > 答案解析：构造函数、析构函数、拷贝构造函数都是特殊的成员函数，友元则不是成员函数。所以选择C项。 
21. 关于对类的描述中，错误的是（ ）。:  **类就是C语言中的结构类型**
    
    > 答案解析：类是具有相同的属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和操作两个主要部分。 类是一种用户自己构造的数据类型，但不是C语言中的结构类型；类要先声明后使用、是具有唯一标识符的实体；类是创建对象的样板。
22. 以下叙述中正确的是（ ）。:  **在类中，不作特别说明的数据成员均为私有类型**
    
    > 答案解析：C＋＋中声明类中无访问权限的关键字，则所有成员默认声明为private权限。类必须在其成员使用之前先进行声明。
23. 类的构造函数被自动调用执行的情况是在定义该类的（）:  **对象时**
    
    > 答案解析：建立对象时，自动构造函数的初始化对象，是系统自动调用的。而成员函数、友元函数，需要用户直接调用，因此选择C项。 
24. 下列变量命名中，非法的是（ ）。:  **A* *LONG**
    
    > 答案解析：C++变量命名只能有大小写字母、下划线和数字组成，且数字不能开头。
25. 假定一个类的构造函数为A(int aa,int bb){a=aa++;b=a*++bb;}，则执行A x(4,5);语句后，x.a和x.b的值分别为（）:  **4和24**
    
    > 答案解析：执行构造函数将数据成员进行赋值，aa++是后加，先赋值a＝4，++bb,bb变量值先自加为6，再与a相乘，所以b＝24。 
26. 类的析构函数是对一个对象进行以下哪种操作时自动调用的是（）:  **撤销**
    
    > 答案解析：删除对象或结束程序时，自动调用析构函数。 
27. 以下说法中不正确的是（ ）。:  **主函数必须出现在固定位置**
    
    > 答案解析：C++程序中必须有一个主函数main()，主函数可以在任何地方出现，而且程序的执行一定是从main()的第一条语句开始执行。
28. 已知类A是类B的友元，类B是类C的友元，则（）:  **类C的成员函数可以访问类B的对象的任何成员**
    
    > 答案解析：使用友元可以访问所有成员；友元关系不能被继承；友元关系是单向的，不具有交换性。所以，B项和D项错误。友元关系不具有传递性。所以，A项错误。 
29. 考虑函数原型void pass（int x，int y =5，char z='*')，下面的函数调用中，属于不合法调用的是（ ）。:  **pass (6,'#')**
    
    > 答案解析：函数默认参数必须在函数原型中说明，默认参数可以多于1个，但必须放在参数序列的后部；如果某个默认参数需要指明一个特定值，则在此之前的所有参数都必须赋值。 在实际调用函数时，如不给出有默认参数的值，则取默认值。选项C，要将'#'传给第二个参数y，数据类型不同，出错。
30. 下列关于虚函数的描述中，正确的是（ ）。:  **虚函数只能是类中的一个成员函数，但不能是静态成员**
    
    > 答案解析：编译器对调用虚函数进行动态联编，这种多态性是程序运行到需要的语句处才动态确定的，所以称为运行时的多态性。不过，使用虚函数并不一定产生多态性，也不一定使用动态联编。
31. 若有定义int *p=new int(0)，则下列说法正确的是（ ）。:  **通过运算符new，分配一个整型数据的存储空间，并将其内存地址赋予指针变量**
    
    > 答案解析：int *p=new int(0)的含义是通过运算符new，分配一个整型数据的存储空间，并将其内存地址赋予指针变量p。
32. 静态成员函数没有（）:  **this指针**
    
    > 答案解析：静态成员函数是普通的函数前加入static,它具有函数的所有的特征：返回类型、形参，所以使用静态成员函数，指针可以作为形参，也具有返回值。静态成员是类具有的属性，不是对象的特征，而this表示的是隐藏的对象的指针，因此静态成员函数没有this 指针。静态成员函数当在类外定义时，要注意不能使用static关键字作为前缀。由于静态成员函数在类中只有一个拷贝（副本），因此它访问对象的成员时要受到一些限制：静态成员函数可以直接访问类中说明的静态成员，但不能直接访问类中说明的非静态成员；若要访问非静态成员时，必须通过参数传递的方式得到相应的对象，再通过对象来访问。 
33. 下面关于对象概念的描述中错误的是（ ）。:  **任何对象都必须有继承性**
    
    > 答案解析：继承是一个类可以获得另一个类的特性的机制，支持层次概念，通过继承，低层的类只需定义特定属于它的特征，而共享高层的类中的特征。类是具有相同的属性和操作的一组对象的集合，对象是属性和方法的封装体，对象间的通信靠消息传递。
34. 构造函数不具备的特征是（）:  **构造函数必须指定类型说明**
    
    > 答案解析：构造函数无返回类型不能继承但可以重载，所以选择D项。 
35. 假定AB为一个类，则执行“AB a(2), b[3],*p[4];”语句时调用该类构造函数的次数为（）:  **4**
    
    > 答案解析：a(2)调用1次带参数的构造函数，b[3]调用3次无参数的构造函数，指针没有给它分配空间，没有调用构造函数。所以共调用构造函数的次数为4。 
36. 以下关于运算符重载的描述中，错误的是:  **运算符重载其实就是函数重载**
    
    > 答案解析：C++中关键字operator和运算符连用就表示一个运算符函数。类运算符比友元运算符少一个参数，这是因为类运算符函数作为成员函数时具有this指针。C++的任何运算都是通过函数来实现的，运算符重载其实就是函数重载，这就是运算符重载的实质。 
37. 关于this指针使用说法正确的是（）:  **保证每个对象拥有自己的数据成员，但共享处理这些数据的代码**
    
    > 答案解析：this指针是隐藏的，可以使用该指针来访问调用对象中的数据。基类的成员在派生类中能否访问，与继承方式有关，与this没有关系。所以选择A项。 
38. 以下有关类与对象的叙述中，错误的是（ ）。:  **只要是某个类的对象，那么该对象就可以访问这个类的所有成员**
    
    > 答案解析：类是具有相同的属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和操作两个主要部分。对于一个具体的类，它有许多具体的个体，这些个体叫作“对象”。每个类的属性和操作分为私有和公有两种类型，对象的外部只能访问对象的公有部分，而不能直接访问对象的私有部分。
39. 以下有关构造函数的叙述中，错误的是（ ）。:  **在一个类中构造函数有且仅有一个**
    
    > 答案解析：构造函数的函数名与结构同名，专门用于初始化结构的对象的函数；构造函数在定义对象时自动执行；构造函数可以在类体内声明在类体外实现。构造函数可以有参数、可以重载、因此可以有多个构造函数。
40. 下面程序![image-20210728115425901](https://gitee.com/lcxm/images/raw/master/typora/20210728115427.png)的输出结果是（ ）。:  **3**
    
    > 答案解析：因为a<b不成立，其后面的两条语句都不会被执行到，直接执行cout<<c<<end1输出c的值3。

### 平时测验三

1. 在私有继承的情况下，基类成员在派生类中的访问权限（）:  **受限制**
    
    > 答案解析：私有继承下，基类中的公有或保护成员在派生类中也是私有的，所以选择A选项。 
2. 下面叙述中错误的是（ ）。:  **C++程序在程序执行过程中对预处理命令进行处理**
    
    > 答案解析：预处理命令在源程序编译之前处理，预处理命令都以“#”开头，后面没有“；”，一行只能写一条预处理命令，预处理命令不是C++的一部分。
3. 下列关于类的权限的描述错误的是（ ）。:  **类本身的成员函数只能访问自身的私有成员**
    
    > 答案解析：类本身的成员函数既可以访问自身的私有成员，更可以访问自身的公有成员。
4. 非数组指针或引用型变量做实参时，它和对应虚参之间的数据传递方式是（ ）。:  **单向值传递**
    
    > 答案解析：
5. 已知：print()函数是一个类的常成员函数，无返回值，下列表示中正确的是（ ）。:  **void print() const**
    
    > 答案解析：常成员函数的声明形式：类型标识符 函数名（参数列表） const；.
6. 下列关于类的继承描述中，错误的是（ ）。:  **派生类可以访问基类的所有数据成员，也能调用基类的所有成员函数**
    
    > 答案解析：派生类继承了基类所有的数据成员和成员函数。相对基类，派生类可以有以下变化：增加新的成员；重新定义已有的成员函数；改变基类成员的访问权限。一个基类可以有多个派生类，一个派生类可以有多个基类。
7. 在公有继承的情况下，基类的公有或保护成员在派生类中的访问权限（）:  **保持不变**
    
    > 答案解析：继承方式的不同派生类成员的权限也不同，采用公有继承，除了私有无法访问外，公有、保护在派生类中保持不变，所以选择B项。 
8. 以下基类中的成员函数表示纯虚函数的是（）:  **virtual void tt()=0**
    
    > 答案解析：当在基类中不能为虚函数给出一个有意义的实现时，可以将其声明为纯虚函数，实现由派生类完成。格式：virtual<函数返回类型说明符><函数名>(<参数表>)=0;。 
9. if与else在使用过程中为避免嵌套出现二义性，C++中规定与else子句配对的是（ ）。:  **其之前最近且尚未配对的if语句**
    
    > 答案解析：C++中规定与else子句配对的是其之前最近且尚未配对的if语句。
10. 静态成员函数不能说明为（）:  **虚函数**
    
    > 答案解析：使用关键字static声明的成员函数就是静态成员函数，静态成员函数也属于整个类而不属于类中的某个对象，它是该类的所有对象共享的成员函数。静态成员函数可以在类体内定义，也可以在类外定义。当在类外定义时，要注意不能使用static关键字作为前缀。由于静态成员函数在类中只有一个拷贝（副本），因此它访问对象的成员时要受到一些限制：静态成员函数可以直接访问类中说明的静态成员，但不能直接访问类中说明的非静态成员；若要访问非静态成员时，必须通过参数传递的方式得到相应的对象，再通过对象来访问。虚函数是非静态的、非内联的成员函数。静态成员函数不能被说明为虚函数。 
11. 当一个类的某个函数被说明为virtual时，该函数在该类的所有派生类中（）:  **都是虚函数**
    
    > 答案解析：在基类声明为virtual的函数为虚函数，在派生类中只要有相同的函数（函数名相同、返回值相同、形参类型和个数相同）即使不用virtual说明，也都是虚函数。 
12. 类B是类A的公有派生类，类A和类B中都定义了虚函数func(),p是一个指向类A对象的指针，则p->A::func()将（）:  **调用类A中的函数func()**
    
    > 答案解析：考察指向类成员指针的使用。A::func()是明确调用A类的func函数，所以不管p指向基类或者派生类对象，都执行基类A的虚函数。注意p->A::func()和p->fun();进行区分。如果使用p->fun()，因为p指向派生类对象，由动态多态性可知要调用派生类的虚函数。 
13. 有关多态性说法不正确的是（）:  **运行时的多态性可通过模板和虚函数实现**
    
    > 答案解析：多态性分为静态的和动态的。静态通过函数的重载来实现，动态是通过基类指针或基类引用和虚函数来实现的。所以错误的是C项。 
14. 下面叙述正确的是（ ）。:  **继承的总是成员函数接口**
    
    > 答案解析：继承的总是成员函数的接口，对于基类是正确的任何事情，对于它的派生类必须也是正确的，反之则不然。 
15. 下列关于友元函数的描述，正确的是（ ）。:  **友元函数可以存取私有成员、公有成员和保护成员**
    
    > 答案解析：可以在类A中通过关键字friend声明或定义某个独立函数或另一个类B的某个成员函数或另一个类B为类A的友元函数，友元函数可以无限制地存取类A的成员（包括私有、公有和保护成员）。友元函数可在类中的私有或公有部分通过关键字friend说明或定义，但如在类中声明，而在类外定义，就不能再在类外使用friend关键字。类友元函数应被看作类的接口的一部分，使用它的主要目的是提高效率，因为它可以直接访问对象的私有成员，从而省去调用类的相应成员函数的开销。
16. 下列说法不正确的是（ ）。:  **主函数main中定义的变量在整个文件或程序中有效**
    
    > 答案解析：主函数main中定义的变量只在主函数中有效。
17. 下面关于C++字符数组的叙述中，错误的是（ ）。:  **可以在赋值语句中通过赋值运算符“=”对字符数组整体赋值**
    
    > 答案解析：
18. 如果从原有类定义新类可以实现的是（）:  **继承机制**
    
    > 答案解析：继承指在原有类的基础上产生新类。数据封装即数据和操作组合在一起，形成类。信息的隐藏，通过访问权限来实现。数据抽象，将事物的特征抽象为数据成员或服务。因此选择C项。 
19. 对基类和派生类的关系描述中，错误的是（）:  **基类继承了派生类的属性**
    
    > 答案解析：派生类的成员一个是来自基类，一个来自本身，所以派生类是基类的扩展，也是基类的具体化和特殊化展。B项基类不能继承派生类成员，所以错误。 
20. 在保护继承的情况下，基类成员在派生类中的访问权限（）:  **都降一级使用**
    
    > 答案解析：保护派生使原来的权限都降一级使用，即private变为不可访问；protected变为private；public变为protected。 
21. 所谓数据封装就是将一组数据和与这组数据有关操作组装在一起，形成一个实体，这实体也就是（ ）。:  **类**
    
    > 答案解析：类是具有相同的属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性（数据成员）和操作（成员函数）两个主要部分。
22. 要是一个类成为抽象类，这个类应具有的条件是（ ）。:  **至少有一个纯虚函数**
    
    > 答案解析：抽象类至少含有一个虚函数，而且至少有一个虚函数是纯虚函数。 
23. 在公有派生类的成员函数不能直接访问基类中继承来的某个成员，则该成员一定是基类中的（）:  **私有成员**
    
    > 答案解析：在派生类中基类的保护或者基类公有都可以直接访问，基类的私有成员只能是基类的成员函数来访问。所以选择A项。 
24. 若二维数组y有m列，则位于y[i][j]之前的元素数量是（ ）。:  **i * m +j**
    
    > 答案解析：y[i][j]前面的元素有前i行i * m个元素再加上第i行第j列前面的j个元素，一共i * m +j个元素。
25. 关于构造函数的说法，不正确的是（ ）。:  **没有定义构造函数时，系统将不会调用它**
    
    > 答案解析：当没有为一个类定义任何构造函数的情况下，C++编译器会自动建立一个不带参数的、函数体为空的构造函数，这就是默认构造函数。构造函数不能在程序中显式调用，它是由系统自动调用的。为了提高安全性和效率，构造函数的名字必须和类名相同，并在定义构造函数时不能指定返回类型，即不要返回值，即使是void类型也不可以。
26. 假设ClassY:publicX，即类Y是类X的派生类，则说明一个Y类的对象时和删除Y类对象时
		        ，调用构造函数和析构函数的次序分别为（）:  **X,Y；Y,X**
    
    > 答案解析：派生类构造函数执行顺序是先调用基类构造函数，然后派生类的构造函数体。析构函数在执行过程与构造函数调用的顺序相反，所以选择A项。 
27. C++类体系中，不能被派生类继承的有（）:  **构造函数**
    
    > 答案解析：构造函数和析构函数不能被继承。 
28. 下面不能够判断字符串S是空串的是（ ）。:  **if(S==’\0’)**
    
    > 答案解析：S是字符串，S本身代表字符串本身及其首地址，也可以理解为是存放字符串的数组的数组名，选项A是正确的，因为如果字符串的第一个字符的ASCII码值是0（字符串的结束标记的\0的ASCII码值就是0），说明就是空串。选项B，if(strlen(S)==0)是利用系统函数判断字符串S的长度是否等于0，当然能够判断字符串S是空串。选项C，if(strcmp(S，””)==0) 是利用系统函数比较字符串S和空串是否相等，当然能够判断字符串S是否是空串。选项D，if(S==’\0’)中的S==’\0’这个表达式左边是字符串，右边是字符，显然是非法的，如果改写成if(S==“\0”)就可以判断字符串S是否是空串。
29. 下列输出字符‘d’的方法中，错误的是（ ）。:  **cout<<put(‘d’)**
    
    > 答案解析：cout.put（）是一个输出字符的函数，cout.put(‘d’) 相当于cout<<‘d’。选项A是非法语句。
30. 逻辑运算符两侧运算对象的数据（ ）。:  **可以是任何类型的数据**
    
    > 答案解析：逻辑运算符两侧运算对象的数据可以是任何类型的数据。
31. 按照标识符的要求，不能组成标识符的符号是（ ）。:  **连接符**
    
    > 答案解析：组成标识符的符号可以是大小写字母、下划线和数字，且数字不能打头。
32. 声明实函数的目的是使（    ）。:  **派生类既继承强制实现，又继承函数接口**
    
    > 答案解析：声明实函数的目的，是使派生类既能继承基类对此实函数的实现，又能继承实函数提供的接口。 
33. 在C++中，函数原型不能标识（ ）。:  **函数的功能**
    
    > 答案解析：函数原型可以标识函数的返回类型、函数参数的个数和函数参数类型，但不能标识函数的功能。
34. 下面叙述正确的是（    ）。:  **声明虚函数的目的是使派生类既能继承默认的实现，又能继承函数接口**
    
    > 答案解析：声明纯虚函数的目的，是使派生类仅仅继承函数接口，而纯虚函数的实现则由派生类去完成；声明虚函数的目的，是使派生类既能继承基类对此虚函数的实现，又能继承虚函数提供的接口； 
35. 下面叙述不正确的是（）:  **基类的公有成员在派生类中仍然是公有的**
    
    > 答案解析：继承方式有三种：公有、私有和保护。多继承中，多个基类具有同名成员，在它们的子类中访问这些成员，就产生了二义性，但进行访问时，不能存在二义性。赋值兼容规则是指派生类对象可以当作基类对象使用，只要存在继承关系，所以单继承或多继承都适用。基类中的公有成员采用私有继承时，在派生类中变成了私有成员，所以D项错误。 
36. 关于引用，下列的说法中错误的是（ ）。:  **在声明引用时，要给它另开辟内存单元**
    
    > 答案解析：引用就是为现有的对象起个别名，别名的地址与引用对象的地址是一样的，使用引用时没有分配新的存储区域。引用主要是用来作函数的形参和函数的返回值；对象在引用前必须先初始化。
37. C++的继承性允许派生类继承基类的（）:  **部分特性，并允许增加新的特性或重定义基类的特性**
    
    > 答案解析：派生类有两类成员：一是基类，二是自身类。派生类中的成员不能访问基类中的私有成员，可以访问基类中的公有成员和保护成员。  
38. 对使用关键字new所开辟的动态存储空间，释放时必须使用（ ）。:  **delete**
    
    > 答案解析：C++为结构动态分配内存的一般格式为：指针名＝new 结构名；当不再使用这个空间时，必须使用delete 释放空间，格式为：delete 指针名；。
39. 下列输出语句中，正确的是（ ）。:  **cout<<("%s\n","hello")**
    
    > 答案解析：%c是输出单个字符的格式控制符；选项C中"c"是字符串，不能用c%格式输出。%s是输出字符串的格式控制符。
40. 所谓多态性是指 （）:  **不同的对象调用相同名称的函数**
    
    > 答案解析：多态性有两种静态多态性和动态多态性，静态多态性是指调用同名函数，由于参数的不同调用不同的同名函数；动态多态性是指不同对象调用同名函数时，由于对象不同调用不同的同名函数。 多态性肯定具有相同的函数名，所以选择B项。 



### 平时测验四

1. 下列不是函数重载所要求的条件是:  **函数返回值类型不同**
    
    > 答案解析：函数重载的函数名必须相同，两个重载函数必须在下列一个或两个方面有所区别：（1）函数的参数个数不同；（2）函数的参数类型不同或者参数类型顺序不同。
2. 下列关于构造函数的描述中，错误的是:  **构造函数不可以重载**
    
    > 答案解析：构造函数主要用来在创建对象时初始化对象，即为对象成员变量赋初始值。一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。构造函数的命名必须和类名完全相同。构造函数不能被直接调用，必须通过new运算符在创建对象时才会自动调用；构造函数可以是内联函数。
3. 使用函数setprecision( int n)必须包含的头文件是(    )。:  **iomanip**
    
    > 答案解析：C＋＋提供了两种格式控制方式，一种是使用iso_base类提供的接口，另一种是使用一种称为操控符的特殊函数，操控符的特点是可直接包含在输入和输出表达式中，因此更为方便，不带形式参数的操控符定义在头文件<iostream>中，带形式参数的操控符定义在头文件<iomanip>中。使用函数setprecision( int n)必须包含的头文件是iomanip。 
4. 下列关于delete运算符的描述中，错误的是:  **它也适用于空指针**
    
    > 答案解析：new与delete是配对使用的，delete必须用于new返回的指针。删除一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象等），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放），释放堆空间后，p成了空指针。delete不能用于空指针，空指针说明已经被释放了。
5. 设有函数模板
		         template <class Q>
		         Q Sum(Q x,Q y)
		         {return (x)+(y);}
		         则下列语句中对该函数模板错误的使用是（）:  **Sum(“AB”,”CD”);**
    
    > 答案解析：由Q Sum(Q x,Q y)可知形参和函数返回值都是同一种数据类型。A、B、C三项都正确。而D项用字符串作为实参，字符串的操作与数值类型不同，要用特殊方法进行字符串的连接和运算。 
6. 使用下列流格式控制符能输出一个换行符的是（ ）:  **endl**
    
    > 答案解析：dec、oct、hex分别是转换基数为十进制形式、八进制形式、十六进制形式。使用endl输出一个换行符并刷新流。 
7. 用来检测提取操作已经到达文件尾的成员函数的是（  ）:  **eof**
    
    > 答案解析：文件流的错误处理成员函数进行错误类型判别，各函数作用如下：bad()    如果进行非法操作，返回true，否则返回flaseeof()      如果提取操作已经到达文件尾，则返回true，否则返回flasegood()    如果没有错误条件和没有设置文件结束标志，返回ture，否则返回flasefail()    与good相反，操作失败返回flase，否则返回true 
8. 实现两个相同类型数加法的函数模板的声明是（）:  **T add(T x,T y)**
    
    > 答案解析：实现两个相同类型数加法结果应该和操作数具有相同类型。进行加法运算后结果也是和参数具有相同类型，需要返回值。A无返回值时要用void,B形参无类型，C形参y没有类型，所以选择D项。 
9. 假设定义了变量i和c，声明了以下的函数模板，错误的调用语句是（ ）
		           int i;char c;
		         temlate <class T>
		           T main(T x, T y) {return (x<y)?x:y}:  **min(i,c)**
    
    > 答案解析：函数min的两个参数的数据类型是一样的，在调用min函数时两个参数的数据类型必须一样。选项A和B显然两个参数的数据类型一样，选项C使用了强制转换，使得两个参数的数据类型一样。 
10. 在面向对象的程序设计中，首先在问题域中识别出若干个 （）:  **类**
    
    > 答案解析：面向过程的和面向对象都具有函数、文件和过程这些概念，而面向对象程序才有类和对象的特征。所以选择B。 
11. 执行下列代码
		             int b=100；
		             cout<<"Hex："<<hex<<b；
		             程序的输出结果是（    ）。:  **Hex：64**
    
    > 答案解析：按照十六进制输出b的值为64. 
12. 关于成员函数特征的描述中，错误的是:  **成员函数一定是内联函数**
    
    > 答案解析：而后者一般为一些短小的函数（5行以内），也就是内联函数。
13. 下面关于类模板叙述不正确的是（    ）。:  **可以有多个析构函数**
    
    > 答案解析：类模板和类一样，也只能有一个析构函数。 
14. 类模板template<class T>classX({…}；，其中友元函数f1对特定类型T(如float)，使函数f1(X<float>&)成为X<float>模板类的友元，则其说明应为（ ）:  **friend void f1(X<T>&)；**
    
    > 答案解析：友元函数说明的格式：friend 函数类型 函数名（类名&，----）； 
15. 考虑函数原型void test(inta,int b=7,char ch='*')，下面的函数调用中，属于不合法调用的是:  **test(6,'#')**
    
    > 答案解析：题中函数声明带有默认参数，那么在C) 选项的调用中，将会把字符型实参#赋值给整型形参b，这不符合参数传递规则。
16. 下面关于类模板叙述不正确的是(      ):  **不可以通过一个类来派生类模板**
    
    > 答案解析：考查类模板的成分、语法及对象，可以通过一个类来派生类模板。 
17. 下列关于运算符重载的表述中，正确的是:  **在类型转换符函数的定义中不需要声明返回类型**
    
    > 答案解析：（3）重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。
18. 已知：int m=10;下列表示引用的方法中，正确的是:  **int&x=m;**
    
    > 答案解析：引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符&引用名=目标变量名；
19. C++中定义标准输入输出的库为 （ ）:  **stdlib**
    
    > 答案解析：stdio 是C标准库里面的标准输入输出函数库，对应的基本都是标准输入输出等等C语言常用库的定义；C++标准输入输出库的头文件是iostream，C++标准输出库的头文件是ostream。 
20. 友元运算符@obj被C++编译器解释为:  **operator@(obj)**
    
    > 答案解析：双目运算符的情况：如友元运算符obj1＞obj2被C++编译器解释为operator＞(obj1，obj2)，单目运算符的情况：如友元运算符@obj被C++编译器解释为operator@(obj)。
21. 下面关于类模板叙述不正确的选项是（    ）。:  **不可以通过一个类来派生类模板**
    
    > 答案解析：类模板可以有多个参数；类模板可以继承，继承的方法和普通的类一样。声明模板继承之前，必须重新声明类模板。类模板支持单一继承，模板类的基类和派生类都可以是模板类或非模板类。 
22. 下列关于C++标识符的命名不合法的是:  **A#bc**
    
    > 答案解析：构成标识符的符号可以是大小写字母、下划线和数字，且数字不能打头。
23. 局部变量可以隐藏全局变量，那么在有同名全局变量和局部变量的情形时，可以用下列哪一项提供对全局变量的访问:  **作用域运算符**
    
    > 答案解析：在有同名全局变量和局部变量的情形时，局部变量可以隐藏全局变量，但可以作用域运算符：：对全局变量进行访问。
24. 对于int*pa[5];的描述中，正确的是:  **pa是一个具有5个元素的指针数组，每个元素是一个int型指针**
    
    > 答案解析：int *pa[5]中pa是一个具有5个元素的指针数组，每个元素是一个int型指针。int(*pa)[5]中pa是一个指向数组的指针，所指向的数组是5个int型元素。
25. 下列有关模板的描述中，错误的是:  **类模板与模板类是同一个概念**
    
    > 答案解析：一个类模板(类生成类)允许用户为类定义个一种模式，使得类中的某些数据成员、默认成员函数的参数，某些成员函数的返回值，能够取任意类型(包括系统预定义的和用户自定义的)。如果一个类中的数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表一类类。模板类是类模板实例化后的一个产物。
26. 在C++中，类与类之间的继承关系具有:  **传递性**
    
    > 答案解析：在C++中，类与类之间的继承关系具有传递性。比如B继承了A，C继承了B，那么C自然也是继承了A里面的东西。
27. 在C++中，使用流进行输入输出，其中用于键盘输入（）:  **cin**
    
    > 答案解析：标准输入流cin：istream类的对象；标准输出流cout：ostream类的对象；非缓冲型标准出错流cerr：ostream类的对象；缓冲型标准出错流clog：ostream类的对象。 
28. 以下关于this指针的叙述中，正确的是:  **类的非静态成员函数才有this指针**
    
    > 答案解析：this指针是隐藏的，可以使用该指针来访问调用对象中的数据。静态成员函数没有this 指针，类的非静态成员函数才有this指针。
29. 以下类模板定义正确的为:  **template<class T>**
    
    > 答案解析：类模板定义的格式为：template<class T> 。
30. 当使用ofstream流类定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式为 （ ）:  **ios::out**
    
    > 答案解析：ios::out 打开文件进行写操作，这是默认方式。 
31. cin.intget( )函数的功能是（ ）:  **从输入流中读入一个字符**
    
    > 答案解析：cin.intget( )函数的功能与C语言中getchar()基本相同。从输入流中读入一个字符(包括空白字符)，返回值就是该字符的ASCII码。如果碰到输入结束符，则返回值为系统常量EOF。 
32. 使用setw()时需要包含头文件:  **iomanip.h**
    
    > 答案解析：使用setw()时需要包含头文件iomanip.h。
33. 用new运算符创建一维数组的正确形式是:  **float *p=new float[10];**
    
    > 答案解析：float *p=new float[10];的含义是：开辟一个长度为10的float型数组的空间，并把首地址赋予指针变量p，而p是指向float型数据的指针。选项D中对数组的初始化时非法的。
34. 进行文件操作时需要包含头文件 （ ）:  **fstream**
    
    > 答案解析：进行文件操作时需要包含头文件fstream；iostream是C++标准输入输出库的头文件；stdlib是C++标准程序库的头文件；stdio是C语言标准输入输出库的头文件。 
35. 若有以下类型标识符定义：int x=2;char w='a';float y=23.45f;double z=45.6789;则表达式w*x+y-z的结果类型是:  **double**
    
    > 答案解析：表达式的运算结果的数据类型取决于参与运算的操作数的类型及其运算符的类型，表达式w*x+y-z是基本算术运算，操作数z的数据类型是double型，所以运算结果的数据类型就是double型。
36. 使用setw()时需要包含头文件（ ）:  **iomanip**
    
    > 答案解析：使用setw()时需要包含头文件iomanip。
37. 在类定义的外部，可以被访问的成员有:  **public的类成员**
    
    > 答案解析：在类定义的外部，可以被访问的成员只能是public的类成员。
38. 如果有int x,*p;float y,*q;则下面操作中，正确的是:  **p=&x**
    
    > 答案解析：选项C，指针变量p指向整型变量x，正确。
39. 对类中声明的变量，下列描述中正确的是:  **属于该类，某些情况下也可被该类不同实例所共享**
    
    > 答案解析：类中声明的变量属于该类，某些情况下也可被该类不同实例所共享。
40. 进行文件操作时需要包含的头文件是（    ）。:  **fstream**
    
    > 答案解析：进行文件操作时需要包含的头文件是fstream 。

